/* 

Database
---------------

Intended purpose of this script:
- This file contains the data model on which the simulation is based

Contents of this script:
- Data classes 
    A Pseudo data class is parent to child classes and provides them with basic data structure and operations 

*/


// Pseudo data class containing network MR data
class DataClass {

    constructor(nodes, edges) { // Expects nodes and edge as dictionary lists

        // Resource for accessing nodes and edges by ID
        this.nodes = this.toIndex(nodes, 'id');
        this.edges = this.toIndex(edges, 'id');

        // Resources for turning data into a graphs
        //this.G = this.toG(); // jsnx G object
        //this.D3 = this.toD3(); // D3 graph format

    }

    // Index dictionary arrays (items) by key (key) to be searchable {item.id : item}
    toIndex(items, key, desiredProperty=null){
        var indexed = {}

        for (const item of items){

            // Assign edge id if edge
            if(item.source){item[key] = ''+item.source+'_to_'+item.target;}
            else {item[key] = item[key]};

            // If a desiredProperty is given then give {key : desired property}
            // This is used if only one property is desired (e.g., an index of ids : names)
            if(desiredProperty){indexed[item[key]] = item[desiredProperty];}

            // Else give {key : item}
            else{indexed[item[key]] = item;}
            
        };

        return indexed;
    }

    // Export data as list of nodes and edges required by iterating methods and propagation MR
    // The list of nodes and edges are not given as a static resource because they change and need to be dynamically generated by function
    toList(items){
        // Make list of edges and nodes from indexed dictionary
        const list = [];
        for (const [ key, value ] of Object.entries(items)) {
            list.push(value)
        }

        return list;
    }

    // Set objective at random 
    setObjective(){
        const count = Math.floor(Math.random() * Object.keys(this.nodes).length);
        this.objective = this.nodes[Object.keys(this.nodes)[count]];
    }

    // Update node values with new data
    update(nodesToUpdate, newNodeValues){
        
        // Update node data
        for(const node of nodesToUpdate){
            this.nodes[node].prevalence = newNodeValues[node]; // Replace [{oldData}] with [{newData}]
        }

    }

    // Export data as node-edge dictionary (for populating D3 vis)
    toD3(){
        return {nodes: this.toList(this.nodes), links: this.toList(this.edges)};
    }

    // Export data as network graph (jsnx G)
    toG(){

        const G = new jsnx.DiGraph(); // Init G object
        var idDict = {};
        var count = 0;
        var edgeList = [];

        for(const node of this.toList(this.nodes)){
            // Add nodes to graph
            G.addNode(count, node);
            idDict[node.id]=count;
            count++;

            // Add edges
            for(const edge of node.edges){
                const source = edge['id.exposure'];
                const target = edge['id.outcome'];

                switch(true){
                    case (source == undefined || target == undefined): break; // Ignore undefined 
                    case (!(source in idDict)):
                        idDict[source] = count;
                        count++;
                    case (!(target in idDict)):
                        idDict[target] = count;
                        count++;
                    default:
                        edgeList.push([idDict[source], idDict[target], edge]);
                        break;
                }            
            }
        }

        G.addEdgesFrom(edgeList);

        return({G:G, idDict:idDict}) // Return G with all nodes and edges
    }

}

// Class for variables used only by the game
class GameData {

    constructor(nodes, edges) {
        this.nodes = nodes;

        // Make game variables
        this.objective = this.setObjective();
    }

    setObjective(){
        return (this.nodes[0]);
    }

    addLogEntry(entry){
        this.log.push(entry);
    }

}