/* 

Database
---------------

Intended purpose of this script:
- This file contains the data model on which the simulation is based

Contents of this script:
- Data classes 
    A Pseudo data class is parent to child classes and provides them with basic data structure and operations 

*/


// Pseudo data class containing network MR data
class DataClass {

    constructor(nodes, edges) { // Expects nodes and edge as dictionary lists

        // Resource for accessing nodes and edges by ID
        this.nodes = this.toIndex(nodes, 'id');
        this.edges = this.toIndex(edges, 'id');

        // Resources for turning data into a graphs
        this.G = this.toG(); // jsnx G object
        this.D3 = this.toD3(); // D3 graph format

    }

    // Index dictionary arrays (items) by key (key) to be searchable {item.id : item}
    toIndex(items, key, desiredProperty=null){
        var indexed = {}

        for (const item of items){

            /* TEMPORARY : Move to MiRANA: csv to json operation 
            // Make sure node and edge ID strings are safe for use as index keys (e.g., in js numbers are not safe keys since edges[0] returns the first edge whereas edges[e0] correctly returns edge e0)
            if (typeof item[key] == 'string'){
                item[key] = safeStr(item[key]);
            } else {
                let source = safeStr(item.source);
                let target = safeStr(item.target);
                item[key] = [source,target];
                item.source = source
                item.target = target
            } 
            //temp key cleaning
            function safeStr(str){
                return str.replace(/-/g, '_')
            }
            */

            // Assign edge id if edge
            if(item.source){item[key] = ''+item.source+'_to_'+item.target;}
            else {item[key] = item[key]};

            // If a desiredProperty is given then give {key : desired property}
            // This is used if only one property is desired (e.g., an index of ids : names)
            if(desiredProperty){indexed[item[key]] = item[desiredProperty];}

            // Else give {key : item}
            else{indexed[item[key]] = item;}
            
        };

        return indexed;
    }

    // Export data as list of nodes and edges required by iterating methods and propagation MR
    // The list of nodes and edges are not given as a static resource because they change and need to be dynamically generated by function
    toList(items){
        // Make list of edges and nodes from indexed dictionary
        const list = [];
        for (const [ key, value ] of Object.entries(items)) {
            list.push(value)
        }

        return list;
    }

    // Update node values with new data
    update(nodesToUpdate, newNodeValues){
        
        // Update node data
        for(const node of nodesToUpdate){
            this.nodes[node].prevalence = newNodeValues[node]; // Replace [{oldData}] with [{newData}]
        }

    }

    // Export data as node-edge dictionary (for populating D3 vis)
    toD3(){
        return {nodes: this.toList(this.nodes), links: this.toList(this.edges)};
    }

    // Export data as network graph (jsnx G)
    toG(){

        const G = new jsnx.DiGraph(); // Init G object
        
        // Add nodes
        for(const node of this.toList(this.nodes)){
            G.addNode(node.id, node);
        }
        // Add edges
        for(const edge of this.toList(this.edges)){
            G.addEdge(edge.source, edge.target, edge);
        }

        return(G) // Return G with all nodes and edges
    }

}

// Class for variables used only by the game
class GameData extends DataClass {

    constructor(nodes, edges) {
        // Get nodes and edges from parent class
        super(nodes, edges);
        // Make game variables
        this.objective = this.setObjective();
        this.log = [];
    }

    setObjective(){
        return (this.nodes.ieu_a_1187);
    }

    addLogEntry(entry){
        this.log.push(entry);
    }

}