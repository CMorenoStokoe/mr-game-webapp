/* 

Database
---------------

Intended purpose of this script:
- This file contains the data model on which the simulation is based

Contents of this script:
- Data classes 
    A Pseudo data class is parent to child classes and provides them with basic data structure and operations 

*/


// Pseudo data class containing network MR data
class DataClass {

    constructor(nodes, edges) { // Expects nodes and edge as dictionary lists

        // Resource for accessing nodes and edges by ID
        this.nodes = this.toIndex(nodes, 'id');
        this.edges = this.toIndex(edges, 'id');

        // Resources for turning data into a graphs
        //this.G = this.toG(); // jsnx G object
        //this.D3 = this.toD3(); // D3 graph format

    }

    // Index dictionary arrays (items) by key (key) to be searchable {item.id : item}
    toIndex(items, key, desiredProperty=null){
        var indexed = {}

        for (const item of items){
            
            // If a desiredProperty is given then give {key : desired property}
            // This is used if only one property is desired (e.g., an index of ids : names)
            if(desiredProperty){indexed[item[key]] = item[desiredProperty];}

            // Else give {key : item}
            else{indexed[item[key]] = item;}
            
        };

        return indexed;
    }

    // Export data as list of nodes and edges required by iterating methods and propagation MR
    // The list of nodes and edges are not given as a static resource because they change and need to be dynamically generated by function
    toList(items){
        // Make list of edges and nodes from indexed dictionary
        const list = [];
        for (const [ key, value ] of Object.entries(items)) {
            list.push(value)
        }

        return list;
    }

    // Get edge by source and target nodes
    getEdge(source, target){
        for(const [key, value] of Object.entries(this.edges)){
            if(value['id.exposure'] == source & value['id.outcome'] == target){
                return(key);
            }
        }

    }

    // Set objective at random 
    setObjective(){
        const count = Math.floor(Math.random() * Object.keys(this.nodes).length);
        this.objective = this.nodes[Object.keys(this.nodes)[count]];
    }

    // Update node values with new data
    update(nodesToUpdate, newNodeValues){
        
        // Update node data
        for(const node of nodesToUpdate){
            this.nodes[node].prevalence = newNodeValues[node]; // Replace [{oldData}] with [{newData}]
        }

    }

    // Remove edges
    updateEdges(newEdges){

        for(const edge of newEdges){
            var edgeToDelete = this.getEdge(edge[0],edge[1]);
            delete this.edges[edgeToDelete];
        }
        console.log(`Deleted ${newEdges.length} edges from DataFrame`)
    }

    // Export data as node-edge dictionary (for populating D3 vis)
    toD3(){
        return {nodes: this.toList(this.nodes), links: this.toList(this.edges)};
    }
    
    // Export data as network graph (jsnx G)
    toG(){

        const G = new jsnx.DiGraph(); // Init G object

        for(const [key, value] of Object.entries(this.nodes)){
            
            /* Add exposure and outcome to source and target
            value.source = value['id.exposure'];
            value.target = value['id.target']; */

            // Add nodes to graph
            G.addNode(key, value);
            
            // Add edges to graph
            for(const edge of value.edges){
                G.addEdge(edge['id.exposure'], edge['id.outcome'], edge);
            }
        }

        return(G) // Return G with all nodes and edges
    }

}