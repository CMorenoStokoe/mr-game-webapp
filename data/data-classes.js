/* 

Database
---------------

Intended purpose of this script:
- This file contains the data model on which the simulation is based

Contents of this script:
- Data classes 
    A Pseudo data class is parent to child classes and provides them with basic data structure and operations 

*/

// Pseudo data class for results of all possible interventions
class EvEData {

    constructor() {

        // Make resource access points
        this.data = null;
        this.initialised = false;

    }

    // Initialise EvE
    init(gameData){

        // Run propagation EvE
        this.data = initialiseEvE(gameData);

        // Flag as initialised
        this.initialised = true;

    }
}

// Pseudo data class containing network MR data
class DataClass {

    constructor(nodes, edges) { // Expects nodes and edge as dictionary lists

        // Resource for accessing nodes and edges by ID
        this.nodes = this.toIndex(nodes, 'id');
        this.edges = this.toIndex(edges, 'id');

        // Resources for turning data into a graphs
        //this.G = this.toG(); // jsnx G object
        //this.D3 = this.toD3(); // D3 graph format

    }

    // Index dictionary arrays (items) by key (key) to be searchable {item.id : item}
    toIndex(items, key, desiredProperty=null){
        var indexed = {}

        for (const item of items){
            
            // If a desiredProperty is given then give {key : desired property}
            // This is used if only one property is desired (e.g., an index of ids : names)
            if(desiredProperty){indexed[item[key]] = item[desiredProperty];}

            // Else give {key : item}
            else{indexed[item[key]] = item;}
            
        };

        return indexed;
    }

    // Export data as list of nodes and edges required by iterating methods and propagation MR
    // The list of nodes and edges are not given as a static resource because they change and need to be dynamically generated by function
    toList(items){
        // Make list of edges and nodes from indexed dictionary
        const list = [];
        for (const [ key, value ] of Object.entries(items)) {
            list.push(value)
        }

        return list;
    }

    // Get edge by source and target nodes
    getEdgeId(source, target){
        for(const [key, value] of Object.entries(this.edges)){
            if(value['id.exposure'] == source & value['id.outcome'] == target){
                return(key);
            }
        }
        return('no entries found');
    }

    // Set objective at random 
    setObjective(specificNode=false){

        // Make sure the objective is valid and can be affected by policies
        var objective = getRandomObjective(this);
        while(isInvalid(objective)){
            objective = getRandomObjective(this);
        }

        // When a valid objective is found, set it
        this.objective = objective;

        // If a specific objective is given, set objective to this node
        if(specificNode){this.objective = this.nodes[specificNode]};

        // Function to pick a random objective
        function getRandomObjective(nodeList){

            // Generate random number in range of number of nodes
            const count = Math.floor(Math.random() * Object.keys(nodeList.nodes).length);

            // Select and return a node by this number 
            return(nodeList.nodes[Object.keys(nodeList.nodes)[count]])
        }

        // Function to check whether the node is valid
        function isInvalid(node){
            for(const edge of node.edges){
                if(edge['id.outcome'] == node.id){return false}
            }
            return true
        }
    }

    // Update node values with new data
    update(result){
        
        // Update node data
        for(const [key, value] of Object.entries(result)){

            // Get new prevalence value
            var newNodePrevalence = this.nodes[key].prevalence += value;

                // Clip prevalence to within min/max limits
                newNodePrevalence = Math.min(this.nodes[key].max, newNodePrevalence);
                newNodePrevalence = Math.max(this.nodes[key].min, newNodePrevalence);

            // Update prevalence related values for node (e.g., change and progress bar width)
            this.setPrevalenceValues(key, newNodePrevalence);
        }
    }
        
    // Function to set prevalence values of node
    setPrevalenceValues(nodeId, prevalence){

        // Set extra data variables for showing prevalence changes

            // Absolute current prevalence
            this.nodes[nodeId].prevalence = prevalence;
        
            // Prevalence change in native units
            this.nodes[nodeId].change_raw = prevalence - this.nodes[nodeId].average;

            // Prevalence change converted to 0-100% scale
            this.nodes[nodeId].change = standardise(this.nodes[nodeId]).prevalenceChange;

            // Prevalence change converted to % change from midpoint (for display on a progress bar)
            this.nodes[nodeId].change_bar = Math.min(100, Math.max(0,
                this.nodes[nodeId].change/2 + 50 // Percentage expressed as deviation from 50% starting point in a bar 
            ))
    }

    // Remove edges
    updateEdges(newEdges){ console.log(`Deleting ${newEdges.length} edges from DataFrame`, newEdges);

        for(const edge of newEdges){
            const edgeId = this.getEdgeId(edge[0],edge[1]);

            // Delete edge from edge list
            delete this.edges[edgeId];
            
            // Delete edges from list of edges for each node
            for(const node of edge){
                const index = edgeIndex(edge[0], edge[1], this.nodes[node].edges);
                this.nodes[node].edges.splice(index, 1);
            }
        }

        // Function to find and remove edges from node edge list
        function edgeIndex(exposure, outcome, edges){
            // Identify and delete edge from node edge lists
            for(const i in edges){
                if(edges[i]['id.exposure']==exposure && edges[i]['id.outcome']==outcome){
                    return(i);
                }
            }
        }
    }

    // Export data as node-edge dictionary (for populating D3 vis)
    toD3(){
        return {nodes: this.toList(this.nodes), links: this.toList(this.edges)};
    }
    
    // Export data as network graph (jsnx G)
    toG(){

        const G = new jsnx.DiGraph(); // Init G object

        for(const [key, value] of Object.entries(this.nodes)){

            // Add nodes to graph
            G.addNode(key, value);
            
            // Add edges to graph
            for(const edge of value.edges){
                G.addEdge(edge['id.exposure'], edge['id.outcome'], edge);
            }
        }

        return(G) // Return G with all nodes and edges
    }

}